---
import LintPopover from '@components/app/home/LintPopover/LintPopover.astro';
import Card from '@components/ui/Card.astro';
import { INPUT } from '@config/input';
import { getLocale, getLocaleMessages } from '@i18n/index.ts';
import type { WithChildren } from '../../../types.ts';

/**
 * The main counter input textarea.
 */
type Props = WithChildren<false>;

const { label, placeholder } = getLocaleMessages(getLocale(Astro)).input;
---

<Card
	id={INPUT.id}
	aria-label={label}
	aria-placeholder={placeholder}
	spellcheck="false"
	role="textbox"
	autofocus
/>
<LintPopover />

<style>
	/* There's currently no way to style these all at once :( */
	::highlight(Agreement) {
		text-decoration: var(--Agreement) underline var(--b-lg);
	}

	::highlight(BoundaryError) {
		text-decoration: var(--BoundaryError) underline var(--b-lg);
	}

	::highlight(Capitalization) {
		text-decoration: var(--Capitalization) underline var(--b-lg);
	}

	::highlight(Eggcorn) {
		text-decoration: var(--Eggcorn) underline var(--b-lg);
	}

	::highlight(Enhancement) {
		text-decoration: var(--Enhancement) underline var(--b-lg);
	}

	::highlight(Formatting) {
		text-decoration: var(--Formatting) underline var(--b-lg);
	}

	::highlight(Grammar) {
		text-decoration: var(--Grammar) underline var(--b-lg);
	}

	::highlight(Malapropism) {
		text-decoration: var(--Malapropism) underline var(--b-lg);
	}

	::highlight(Miscellaneous) {
		text-decoration: var(--Miscellaneous) underline var(--b-lg);
	}

	::highlight(Nonstandard) {
		text-decoration: var(--Nonstandard) underline var(--b-lg);
	}

	::highlight(Punctuation) {
		text-decoration: var(--Punctuation) underline var(--b-lg);
	}

	::highlight(Readability) {
		text-decoration: var(--Readability) underline var(--b-lg);
	}

	::highlight(Redundancy) {
		text-decoration: var(--Redundancy) underline var(--b-lg);
	}

	::highlight(Regionalism) {
		text-decoration: var(--Regionalism) underline var(--b-lg);
	}

	::highlight(Repetition) {
		text-decoration: var(--Repetition) underline var(--b-lg);
	}

	::highlight(Spelling) {
		text-decoration: var(--Spelling) underline var(--b-lg);
	}

	::highlight(Style) {
		text-decoration: var(--Style) underline var(--b-lg);
	}

	::highlight(Typo) {
		text-decoration: var(--Typo) underline var(--b-lg);
	}

	::highlight(Usage) {
		text-decoration: var(--Usage) underline var(--b-lg);
	}

	::highlight(WordChoice) {
		text-decoration: var(--WordChoice) underline var(--b-lg);
	}

	#input {
		min-height: 18rem;
		max-height: var(--max-w);
		padding: var(--p-md);
		background-color: var(--bg-2);
		color: var(--fg);
		caret-color: var(--p);
		border: none;
		font-family: var(--f-body);
		font-size: var(--f-md);
		font-weight: var(--f-normal);
		transition-duration: var(--d-md);
		resize: block;
		view-transition-name: input;
		line-height: inherit;
		/* Prevent whitespace from being collapsed when `contenteditable` is unset */
		white-space: pre-wrap;
		overflow-wrap: break-word;
		/* Revert `overflow:hidden` set by Card */
		overflow-block: auto;
		contain: strict;

		/* Disabled */
		&:not([contenteditable]) {
			opacity: var(--o-md);
		}

		&:empty::before {
			content: attr(aria-placeholder);
			opacity: var(--o-md);
		}
	}
</style>

<script>
	import {
		clearLintPopover,
		updateLintPopover,
	} from '@components/app/home/LintPopover/lint-popover-client.ts';
	import { INPUT } from '@config/input.ts';
	import { LINT_KINDS, type LintKind } from '@lib/harper.ts';
	import { $input, $lintChunkMap } from '@stores/index.ts';
	import { immediateDebounce } from '@utils/immediate-debounce.ts';
	import {
		addScrollStartListener,
		addValueToMapSet,
		getDefinedElementById,
	} from '@utils/index.ts';
	import { type Lint } from 'harper.js';
	import type { LintChunkMap, RangeIndices } from '../../../types.ts';

	/**
	 * Creates a Range object for a text node.
	 *
	 * @param node - The text node to create the range within
	 * @param start - Starting character offset
	 * @param end - Ending character offset
	 * @returns A Range object with the specified boundaries
	 */
	function createRange(node: Node, start: number, end: number) {
		const range = new Range();

		range.setStart(node, start);
		range.setEnd(node, end);

		return range;
	}

	/**
	 * Finds the lint of a range that intersects with the given coordinates. If no range is found, returns undefined.
	 *
	 * @param x The x coordinate of the point.
	 * @param y The y coordinate of the point.
	 * @returns The lint of the range that intersects with the given coordinates.
	 */
	function findIntersectingRangeLint(x: number, y: number) {
		const pos = document.caretPositionFromPoint(x, y);

		// Prevent clicks from being associated with a range when they are beyond the end of the input
		if (!pos || pos.offset === pos.offsetNode.nodeValue?.length) return;

		return allLints[pos.offset];
	}

	/**
	 * Updates CSS Custom Highlights for lint issues in the input text.
	 *
	 * @param lintChunkMap - Map of lint chunks to highlight
	 */
	function updateHighlights(lintChunkMap: Readonly<LintChunkMap>) {
		const textNode = input.firstChild;

		if (!textNode) return;

		const inputLength = textNode.nodeValue?.length ?? 0;
		const newLintKindToHighlightMap = new Map<LintKind, Highlight>();

		allLints = [];

		for (const lintChunk of Object.values(lintChunkMap)) {
			if (!lintChunk) continue;

			for (const lint of lintChunk.lints) {
				const lintKind = lint.lint_kind() as LintKind;
				const span = lint.span();
				const start = lintChunk.start + span.start;
				const end = lintChunk.start + span.end;

				// If the end index is out of bounds, skip it and the remaining lints (assuming they are in order)
				// This may happen if the input text is modified before we get the lint result back
				if (end > inputLength) break;

				const range = createRange(textNode, start, end);

				addValueToMapSet(newLintKindToHighlightMap, lintKind, range, Highlight);

				for (let i = start; i <= end; i++) {
					allLints[i] = lint;
				}
			}
		}

		// Replace all the highlights at once to prevent flickering
		for (const lintKind of LINT_KINDS) {
			CSS.highlights.set(
				lintKind,
				newLintKindToHighlightMap.get(lintKind) ?? new Highlight(),
			);
		}
	}

	/**
	 * Returns a single text node for the input element.
	 *
	 * Normalizes multiple text nodes and removes empty or newline-only nodes.
	 *
	 * @returns The text node, or `undefined` if none exists
	 */
	function getTextNode() {
		const numOfChildren = input.childNodes.length;

		// If the input has multiple text nodes, normalize them into one
		if (numOfChildren > 1) {
			input.normalize();
		}

		const textNode = input.firstChild;

		// There's nothing here
		if (!textNode) return;

		const { nodeValue } = textNode;

		// Remove the text node if it is empty so that placeholder text can be shown with CSS
		if (!nodeValue || nodeValue === '\n') {
			input.removeChild(textNode);

			return;
		}

		return textNode;
	}

	/**
	 * Computes the visible text range within the input element.
	 *
	 * Uses caret positions at the element bounds and clamps the result
	 * to the length of the current text node.
	 *
	 * @param textNode The text node to measure.
	 * @returns A tuple `[start, end]` indicating the visible range of text.
	 */
	function getVisibleRangeIndices(textNode: Node | undefined): RangeIndices {
		const { top, left, bottom, right } = input.getBoundingClientRect();
		const maxEnd = textNode?.nodeValue?.length ?? 0;
		const start = document.caretPositionFromPoint(left, top)?.offset ?? 0;
		const end =
			document.caretPositionFromPoint(right, bottom)?.offset ?? maxEnd;
		const clippedStart = Math.max(start, 0);
		const clippedEnd = Math.min(end, maxEnd);

		return [clippedStart, clippedEnd];
	}

	/**
	 * Extracts the user-visible text from a text node.
	 *
	 * @param textNode The text node to extract text from.
	 * @returns The text content as a string, or an empty string if the node is absent or empty.
	 */
	function getText(textNode: Node | undefined) {
		const text = textNode?.nodeValue;

		if (!text) return '';

		// Browsers may include a trailing newline in the input text, but this is not visible to the user
		if (text.endsWith('\n')) {
			return text.slice(0, -1);
		}

		return text;
	}

	/**
	 * Debounced handler that normalizes the input node and updates the input text store.
	 */
	const updateInputText = immediateDebounce({ delay: 35 }, async () => {
		const textNode = getTextNode();

		clearLintPopover();

		// Setting the initial input value is handled by the preload script on the counter page
		$input.set({
			text: getText(textNode),
			visibleRangeIndices: getVisibleRangeIndices(textNode),
		});
	});

	const input = getDefinedElementById<HTMLDivElement>(INPUT.id);

	// Sparse array which maps an index in the input text to a lint (if any)
	// This gives us really predictable (and freaky) performance when looking up what the user clicked on
	let allLints: Lint[] = [];

	$lintChunkMap.subscribe(updateHighlights);

	input.addEventListener('input', updateInputText);
	input.addEventListener('click', ({ clientX, clientY }) => {
		const lint = findIntersectingRangeLint(clientX, clientY);

		updateLintPopover(lint, clientX, clientY);
	});

	addScrollStartListener(input, clearLintPopover);

	// Wait till the page has loaded before 'enabling' the input
	input.contentEditable = 'plaintext-only';

	updateInputText();
</script>
